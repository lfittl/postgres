<!-- doc/src/sgml/pgstatplans.sgml -->

<sect1 id="pgstatplans" xreflabel="pg_stat_plans">
 <title>pg_stat_plans &mdash; track per-plan call counts, execution times and EXPLAIN texts</title>

 <indexterm zone="pgstatplans">
  <primary>pg_stat_plans</primary>
 </indexterm>

 <para>
  The <filename>pg_stat_plans</filename> module provides a means for
  tracking per-plan statistics and plan texts of all SQL statements executed by
  a server.
 </para>

 <para>
  The module must be loaded by adding <literal>pg_stat_plans</literal> to
  <xref linkend="guc-shared-preload-libraries"/> in
  <filename>postgresql.conf</filename>, because it requires additional shared memory.
  This means that a server restart is needed to add or remove the module.
  In addition, query and plan identifier calculation must be enabled in order for the
  module to be active by setting both <xref linkend="guc-compute-plan-id"/> to <literal>on</literal>
  and <xref linkend="guc-compute-query-id"/> to <literal>auto</literal> or <literal>on</literal>.
 </para>

 <para>
   When <filename>pg_stat_plans</filename> is active, it tracks
   statistics across all databases of the server.  To access and manipulate
   these statistics, the module provides the <structname>pg_stat_plans</structname>
   view and the utility functions <function>pg_stat_plans_reset</function> and
   <function>pg_stat_plans</function>.  These are not available globally but
   can be enabled for a specific database with
   <command>CREATE EXTENSION pg_stat_plans</command>.
 </para>

 <sect2 id="pgstatplans-pg-stat-plans">
  <title>The <structname>pg_stat_plans</structname> View</title>

  <para>
   The statistics gathered by the module are made available via a
   view named <structname>pg_stat_plans</structname>.  This view
   contains one row for each distinct combination of database ID, user
   ID, query ID and plan ID (up to the maximum number of distinct plans
   that the module can track). The columns of the view are shown in
   <xref linkend="pgstatplans-columns"/>.
  </para>

  <table id="pgstatplans-columns">
   <title><structname>pg_stat_plans</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>userid</structfield> <type>oid</type>
       (references <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.<structfield>oid</structfield>)
      </para>
      <para>
       OID of user who executed the statement
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dbid</structfield> <type>oid</type>
       (references <link linkend="catalog-pg-database"><structname>pg_database</structname></link>.<structfield>oid</structfield>)
      </para>
      <para>
       OID of database in which the statement was executed
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>queryid</structfield> <type>bigint</type>
      </para>
      <para>
       Hash code to identify identical normalized queries.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>planid</structfield> <type>bigint</type>
      </para>
      <para>
       Hash code to identify identical plan shapes.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan</structfield> <type>text</type>
      </para>
      <para>
       Plan text of a representative plan. This is similar to the output of
       <literal>EXPLAIN (COSTS OFF)</literal>. Note the plan text will contain constant
       values of the first plan recorded, but subsequent executions of the
       same plan hash code (<structfield>planid</structfield>) with different
       constant values will be tracked under the same entry.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>calls</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times the plan was executed
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>total_exec_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent executing the plan, in milliseconds
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   For security reasons, only superusers and roles with privileges of the
   <literal>pg_read_all_stats</literal> role are allowed to see the plan text,
   <structfield>queryid</structfield> and <structfield>planid</structfield>
   of queries executed by other users. Other users can see the statistics,
   however, if the view has been installed in their database.
  </para>

  <para>
   Plannable queries (that is, <command>SELECT</command>, <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command>, and <command>MERGE</command>)
   are combined into a single <structname>pg_stat_plans</structname> entry whenever
   they have identical plan structures according to an internal hash calculation.
   Typically, two plans will be considered the same for this purpose if they have
   the same <literal>EXPLAIN (COSTS OFF)</literal> output and are semantically
   equivalent except for the values of literal constants appearing in the query plan.
  </para>
  
  <para>
   Note that queries that have not finished executing yet will show in
   <structname>pg_stat_plans</structname> with their plan text, but without
   the <structname>calls</structname> field being incremented. This can be
   used to identify the query plan for a currently running statement by joining
   <link linkend="monitoring-pg-stat-activity-view">pg_stat_activity</link>
   with <structname>pg_stat_plans</structname>, see example usage in
   <xref linkend="pgstatplans-sample-output"/>.
  </para>

  <para>
   Consumers of <structname>pg_stat_plans</structname> should use
   <structfield>planid</structfield> in combination with
   <structfield>queryid</structfield>, <structfield>dbid</structfield>
   and <structfield>userid</structfield> as a stable and reliable identifier
   for each entry, instead of using its plan text. However, it is important
   to understand that there are only limited guarantees around the stability
   of the <structfield>planid</structfield> hash value.  Since the identifier
   is derived from the plan tree, its value is a function of, among other
   things, the internal object identifiers appearing in this representation.
   This has some counterintuitive implications.  For example,
   <filename>pg_stat_plans</filename> will consider two apparently-identical
   plans to be distinct, if they reference a table that was dropped
   and recreated between the creation of the two plans.
   The hashing process is also sensitive to differences in
   machine architecture and other facets of the platform.
   Furthermore, it is not safe to assume that <structfield>planid</structfield>
   will be stable across major versions of <productname>PostgreSQL</productname>.
  </para>

  <para>
   Two servers participating in replication based on physical WAL replay can
   be expected to have identical <structfield>planid</structfield> values for
   the same plan.  However, logical replication schemes do not promise to
   keep replicas identical in all relevant details, so
   <structfield>planid</structfield> will not be a useful identifier for
   accumulating costs across a set of logical replicas.
   If in doubt, direct testing is recommended.
  </para>

  <para>
   Plan texts are stored in shared memory, and limited in length. To increase
   the maximum length of stored plan texts you can increase
   <varname>pg_stat_plans.max_size</varname>. This value can be changed for
   an individual connection, or set as a server-wide setting.
  </para>
 </sect2>

 <sect2 id="pgstatplans-funcs">
  <title>Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>pg_stat_plans_reset() returns void</function>
     <indexterm>
      <primary>pg_stat_plans_reset</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>pg_stat_plans_reset</function> discards statistics and plan texts
      gathered so far by <filename>pg_stat_plans</filename>.
      By default, this function can only be executed by superusers.
      Access may be granted to others using <command>GRANT</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>pg_stat_plans(showplan boolean) returns setof record</function>
     <indexterm>
      <primary>pg_stat_plans</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>

    <listitem>
     <para>
      The <structname>pg_stat_plans</structname> view is defined in
      terms of a function also named <function>pg_stat_plans</function>.
      It is possible for clients to call
      the <function>pg_stat_plans</function> function directly, and by
      specifying <literal>showplan := false</literal> have plan texts be
      omitted (that is, the <literal>OUT</literal> argument that corresponds
      to the view's <structfield>plan</structfield> column will return nulls).  This
      feature is intended to support external tools that might wish to avoid
      the overhead of repeatedly retrieving plan texts of indeterminate
      length.  Such tools can instead cache the first plan text observed
      for each entry themselves, since that is
      all <filename>pg_stat_plans</filename> itself does, and then retrieve
      plan texts only as needed.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="pgstatplans-config-params">
  <title>Configuration Parameters</title>

  <variablelist>
   <varlistentry>
    <term>
     <varname>pg_stat_plans.max</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_stat_plans.max</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_stat_plans.max</varname> is the maximum number of
      plans tracked by the module (i.e., the maximum number of rows
      in the <structname>pg_stat_plans</structname> view).  If more distinct
      plans than that are observed, information about the least-executed
      plans is discarded. The default value is 5000.
      Only superusers can change this setting. Changing the setting requires
      a reload of the server.
     </para>
    </listitem>
   </varlistentry>
  
   <varlistentry>
    <term>
     <varname>pg_stat_plans.max_size</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_stat_plans.max_size</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_stat_plans.max_size</varname> is the maximum length of
      each plan text tracked by the module in bytes. Longer plan texts will be truncated.
      The default value is 2048 (2kB).
      Only superusers can change this setting.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_stat_plans.track</varname> (<type>enum</type>)
     <indexterm>
      <primary><varname>pg_stat_plans.track</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_stat_plans.track</varname> controls which plans
      are counted by the module.
      Specify <literal>top</literal> to track plans by top-level statements (those issued
      directly by clients), <literal>all</literal> to also track nested statements
      (such as statements invoked within functions), or <literal>none</literal> to
      disable plan statistics collection.
      The default value is <literal>top</literal>.
      Only superusers can change this setting.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   The module requires additional shared memory proportional to
   <varname>pg_stat_plans.max</varname> for statistics, as well as
   <varname>pg_stat_plans.max</varname> multiplied by
   <varname>pg_stat_plans.max_size</varname> for plan texts. Note that this
   memory is only consumed when entries are created, and not if
   <varname>pg_stat_plans.track</varname> is set to <literal>none</literal>.
  </para>

  <para>
   These parameters must be set in <filename>postgresql.conf</filename>.
   Typical usage might be:

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_stat_plans'

compute_query_id = on
compute_plan_id = on
pg_stat_plans.max = 10000
pg_stat_plans.max_size = 4096
pg_stat_plans.track = all
</programlisting>
  </para>
 </sect2>

 <sect2 id="pgstatplans-sample-output">
  <title>Sample Output</title>

<screen>
bench=# SELECT pg_stat_plans_reset();

$ pgbench -i bench
$ pgbench -c10 -t300 bench

bench=# \x
bench=# SELECT plan, calls, total_exec_time
  FROM pg_stat_plans ORDER BY total_exec_time DESC LIMIT 5;
-[ RECORD 1 ]---+-----------------------------------------------------------------
plan            | Update on pgbench_tellers                                       +
                |   ->  Seq Scan on pgbench_tellers                               +
                |         Filter: (tid = 5)
calls           | 3000
total_exec_time | 642.8880919999993
-[ RECORD 2 ]---+-----------------------------------------------------------------
plan            | Update on pgbench_branches                                      +
                |   ->  Seq Scan on pgbench_branches                              +
                |         Filter: (bid = 1)
calls           | 1813
total_exec_time | 476.64152700000005
-[ RECORD 3 ]---+-----------------------------------------------------------------
plan            | Update on pgbench_branches                                      +
                |   ->  Index Scan using pgbench_branches_pkey on pgbench_branches+
                |         Index Cond: (bid = 1)
calls           | 1187
total_exec_time | 326.1257549999999
-[ RECORD 4 ]---+-----------------------------------------------------------------
plan            | Update on pgbench_accounts                                      +
                |   ->  Index Scan using pgbench_accounts_pkey on pgbench_accounts+
                |         Index Cond: (aid = 48793)
calls           | 3000
total_exec_time | 21.664690000000093
-[ RECORD 5 ]---+-----------------------------------------------------------------
plan            | Insert on pgbench_history                                       +
                |   ->  Result
calls           | 3000
total_exec_time | 4.365250999999957

session 1:

bench# SELECT pg_sleep(100), COUNT(*) FROM pgbench_accounts;

session 2:

bench=# SELECT query, plan FROM pg_stat_activity
  JOIN pg_stat_plans ON (usesysid = userid AND datid = dbid AND query_id = queryid AND plan_id = planid)
  WHERE query LIKE 'SELECT pg_sleep%';
                         query                         |                plan                
-------------------------------------------------------+------------------------------------
 SELECT pg_sleep(100), COUNT(*) FROM pgbench_accounts; | Aggregate                         +
                                                       |   ->  Seq Scan on pgbench_accounts
(1 row)

</screen>
 </sect2>

 <sect2 id="pgstatplans-authors">
  <title>Authors</title>

  <para>
   Lukas Fittl <email>lukas@fittl.com</email>.
  </para>
 </sect2>

</sect1>
